<!DOCTYPE html>
<html>
  <head>
    <title>Dragging Polygons</title>
 <meta charset="UTF-8">
    <style>

#canvas {
 border: 10px solid gold;
 position: relative;
 margin: 10px;
 padding: 10px;
}
canvas {
 background-color: silver;
 float: left;
}

#canvas>div {
 width: 10px;
 height: 10px;
 position: absolute;
 border: 1px solid green;
 top: 0;
}
    </style>
  </head>

   <body>
<div id="canvas"></div>

<script>



function Rect(x, y, w, h) {
	this.x = x;
	this.y = y;
	this.w = w;
	this.h = h;
}

function Pos(x, y) {
	this.x = x || 0;
	this.y = y || 0;
}

function Node(context, rect, stroke, fill, line) {
	this.initialize(context, rect, stroke, fill, line);
}
Node.WIDTH = 50;
Node.HEIGHT = 50;
Node.FILL = "rgba(255, 69, 0, 1)";
Node.STROKE = "rgba(0, 0, 230, 0.5)";
Node.LINE = 1;
Node.prototype = {
	initialize: function (context, _context, rect, stroke, fill, line) {
		this.context = context;
		this._context = _context;
		this.rect = rect || new Rect(0, 0, Node.WIDTH, Node.HEIGHT);
		this.stroke = stroke || Node.STROKE;
		this.fill = fill || Node.FILL;
		this.line = line || Node.LINE;
		this.index;
	},
	path: function (context) {
		context.beginPath();
		context.rect(this.rect.x, this.rect.y , this.rect.w, this.rect.h);
		context.closePath();
	},
	draw: function () {
		this.path(this.context);
		
		this.context.save();
		this.context.strokeStyle = this.stroke;
		this.context.fillStyle = this.fill;
		this.context.lineWidth = this.line;
		this.context.stroke();
		this.context.fill();
		
		this.context.restore();
	},
	shadow: function (index) {
		this.path(this._context);
		
		this._context.save();
		this._context.fillStyle = this.index = index || this.index;
		this._context.fill();
		this._context.restore();
	},
	move: function(pos) {
		this.rect.x = pos.x;
		this.rect.y = pos.y;
		
		this.draw();
	}
};

function Index() {
	this.initialize();
}
Index.prototype = {
	initialize: function () {
		this.map = {};
		this.index = 0;
	},
	add: function (node) {
		var index = Map.toRGBString(++this.index);
		
		this.map[index] = node;
		
		return index;
	},
	get: function (rgb) {
		return this.map[Map.toRGBString(Map.toRGBNumber(rgb))];
	}
};

function Map(id, w, h) {
	this.initialize(id, w, h);
}
Map.WIDTH = 300;
Map.HEIGHT = 300;
Map.STROKE = "rgba(0,0,230,0.4)";
Map.toRGBString = function (n) {
	return "#"+ Map.toHex((n >> 16) & 255) + Map.toHex((n >> 8) & 255) + Map.toHex(n & 255);
};
Map.toHex = function (n) {
	var s = n.toString(16);
	
	return s.length == 1? "0"+s: s;
};
Map.toRGBNumber = function (rgb) {
	return rgb[0]<<16 | rgb[1]<<8 | rgb[2];
};
Map.prototype = {
	initialize: function (id, w, h) {
		this.map = document.getElementById(id);
		this.canvas = document.createElement("canvas");
		this._canvas = document.createElement("canvas");
		this.context = this.canvas.getContext("2d");
		this._context = this._canvas.getContext("2d");
		this.nodes = [];
		this.copy = null;
		this.index = new Index();
		this.mouse = new Pos();
		this.selectable = null;
		this.selected = null;
		this.offset = new Pos();
		this.handler = {};
		
		this.map.appendChild(this.canvas);
		//this.map.appendChild(this._canvas);
		this._canvas.width = this.canvas.width = w || Map.WIDTH;
		this._canvas.height = this.canvas.height = h || Map.HEIGHT;
		
		var _this = this;
		this.map.onmousemove = function (event) {
			event.preventDefault();
			
			var pos = _this.getPos(event);
			if(pos.x == _this.mouse.x && pos.y == _this.mouse.y) { // 움직임 없는 이벤트 방지
				return;
			}
			
			_this.mouse = pos;
			
			if(_this.selected) { // drag
				_this.drag();
				
				return;
			}
			
			var data = _this._context.getImageData(_this.mouse.x, _this.mouse.y, 1, 1).data, node;
			if(node = _this.index.get(data)) { // 노드 감지
				if(node != _this.selectable) { // enter 이벤트 발생
					_this.dispatchEvent("enter", node);
				}
				else {
					return; // 노드 변화가 없는 이벤트 방지
				}
			}
			else if(_this.selectable){
				_this.dispatchEvent("leave", _this.selectable);
			}
			
			_this.selectable = node;
		};
		
		this.map.onmousedown = function (event) {
			event.preventDefault();
			
			if(_this.selectable) {
				_this.onSelect();
			}
		};
		
		this.map.onmouseup = this.map.onmouseout = function (event) {
			event.preventDefault();
			
			if(_this.selected) {
				_this.onCancel();
			}
		};
	},
	drawGuide: function(pos) {
		this.context.save();
		this.context.beginPath();
		this.context.strokeStyle = Map.STROKE;
		this.context.lineWidth = 0.5;
		this.context.moveTo(pos.x + 0.5, 0);
		this.context.lineTo(pos.x + 0.5, this.canvas.height);
		this.context.moveTo(0, pos.y + 0.5);
		this.context.lineTo(this.canvas.width, pos.y + 0.5);
		this.context.stroke();
		this.context.restore();
	},
	onSelect: function() {
		this.dispatchEvent("select", this.selected = this.selectable);
		
		this.offset = new Pos(this.mouse.x - this.selected.rect.x, this.mouse.y - this.selected.rect.y);
		this.nodes.splice(this.nodes.indexOf(this.selected), 1);
		this.copy = this.invalidate();
		this.selected.draw();
	},
	onCancel: function() {
		this.dispatchEvent("cancel", this.selected);
		
		this.nodes.push(this.selected);
		this.invalidate();
		this.selected = null;
	},
	drag: function() {
		this.context.putImageData(this.copy, 0, 0);
		
		var pos = new Pos(this.mouse.x - this.offset.x, this.mouse.y - this.offset.y);
		this.selected.move(pos);
		this.drawGuide(pos);
	},
	addNode: function() {
		var node = new Node(this.context, this._context, new Rect(Math.floor(Math.random() * this.canvas.width), Math.floor(Math.random() * this.canvas.height), 50, 50));
		
		this.nodes.push(node);
		
		node.draw();
		node.shadow(this.index.add(node));
	},
	invalidate: function() {
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
		this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
		
		for(var i=0, nodes=this.nodes, j=nodes.length; i<j; i++) {
			nodes[i].draw();
			nodes[i].shadow();
		}
		
		return this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
	},
	getPos: function(event) {
		var rect = this.canvas.getBoundingClientRect();
		
		return new Pos(event.clientX - rect.left - this.canvas.clientLeft, event.clientY - rect.top - this.canvas.clientTop);
	},
	on: function (event, handler) {
		this.handler[event] = handler;
	},
	dispatchEvent: function (event, node) {
		if(this.handler[event]) {
			this.handler[event](node);
		}
	}
}

var map = new Map("canvas");

map.addNode();
map.addNode();

map.on("enter", function(node) {
	console.log("enter"+ node);
});
map.on("leave", function(node) {
	console.log("leave"+ node);
});
map.on("select", function(node) {
	console.log("select"+ node);
});
</script>

  </body>
</html>
